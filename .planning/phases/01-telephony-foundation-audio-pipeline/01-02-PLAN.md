---
phase: 01-telephony-foundation-audio-pipeline
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/audio/buffers.py
  - src/state/manager.py
  - src/twilio/client.py
  - src/twilio/handlers.py
  - src/main.py
autonomous: true
requirements:
  - TEL-02
  - TEL-04

must_haves:
  truths:
    - "Server can send audio to Twilio without buffer overflow"
    - "Server tracks call state (idle, listening, speaking)"
    - "Server can initiate outbound calls via Twilio SDK"
    - "Bidirectional audio flows without blocking"
  artifacts:
    - path: "src/audio/buffers.py"
      provides: "Audio streaming with backpressure handling"
      exports: ["AudioStreamer"]
    - path: "src/state/manager.py"
      provides: "Call state machine and lifecycle management"
      exports: ["CallStateManager", "CallState", "CallContext"]
    - path: "src/twilio/client.py"
      provides: "Twilio API client for outbound calls"
      exports: ["create_outbound_call", "generate_twiml"]
  key_links:
    - from: "src/twilio/handlers.py"
      to: "src/audio/buffers.py"
      via: "AudioStreamer instance per call"
      pattern: "AudioStreamer.*websocket"
    - from: "src/twilio/handlers.py"
      to: "src/state/manager.py"
      via: "CallStateManager tracking call lifecycle"
      pattern: "CallStateManager|CallState"
    - from: "src/twilio/client.py"
      to: "src/main.py"
      via: "TwiML endpoint URL reference"
      pattern: "/twiml|VoiceResponse"
---

<objective>
Implement bidirectional audio streaming with backpressure handling, call state management for tracking conversation lifecycle, and outbound call initiation capability via Twilio SDK.

Purpose: Complete the telephony pipeline by adding streaming infrastructure and call control, enabling both inbound and outbound call scenarios.
Output: Full bidirectional streaming capability with state tracking and ability to programmatically initiate calls.
</objective>

<execution_context>
@/Users/lucassenechal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucassenechal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-telephony-foundation-audio-pipeline/01-RESEARCH.md
@.planning/research/STACK.md
@.planning/phases/01-telephony-foundation-audio-pipeline/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement bidirectional audio streaming with backpressure</name>
  <files>
    src/audio/buffers.py
    src/twilio/handlers.py
  </files>
  <action>
Create audio streaming module in src/audio/buffers.py following Pattern 4 from research (bidirectional streaming with backpressure):

```python
"""
Bidirectional audio streaming with backpressure handling.

Prevents buffer overflow when TTS generates audio faster than network can transmit.
Uses bounded queues with timeout to detect stalls.
"""
import asyncio
import json
import logging
from asyncio import Queue
from typing import Optional
from fastapi import WebSocket

logger = logging.getLogger(__name__)

class AudioStreamer:
    """
    Manages bidirectional audio streaming for a single call.

    Implements backpressure: if outbound queue is full, blocks producer
    to prevent memory overflow.
    """

    def __init__(self, websocket: WebSocket, stream_sid: str):
        self.websocket = websocket
        self.stream_sid = stream_sid
        # ~1 second buffer at 20ms per chunk = 50 chunks max
        self.outbound_queue: Queue[str] = Queue(maxsize=50)
        self.running = False
        self._send_task: Optional[asyncio.Task] = None

    async def start(self):
        """Start background task to send queued audio to Twilio"""
        self.running = True
        self._send_task = asyncio.create_task(self._send_loop())
        logger.info(f"AudioStreamer started for stream: {self.stream_sid}")

    async def stop(self):
        """Stop background sending and cleanup"""
        self.running = False
        if self._send_task:
            self._send_task.cancel()
            try:
                await self._send_task
            except asyncio.CancelledError:
                pass
        logger.info(f"AudioStreamer stopped for stream: {self.stream_sid}")

    async def queue_audio(self, audio_payload: str):
        """
        Queue audio for sending to Twilio.

        Implements backpressure: if queue is full, this will block
        until space is available, preventing memory overflow.

        Args:
            audio_payload: Base64-encoded mu-law audio

        Raises:
            asyncio.TimeoutError: If can't queue within 1 second (stall detected)
        """
        try:
            # This blocks if queue is full (backpressure)
            await asyncio.wait_for(
                self.outbound_queue.put(audio_payload),
                timeout=1.0  # Fail if can't queue within 1 second
            )
            logger.debug(f"Queued audio chunk, queue depth: {self.outbound_queue.qsize()}")

        except asyncio.TimeoutError:
            logger.warning(
                f"Audio queue full for stream {self.stream_sid}, dropping packet. "
                f"Queue size: {self.outbound_queue.qsize()}/{self.outbound_queue.maxsize}"
            )
            raise

    async def clear_queue(self):
        """Clear all queued audio (used for interruptions)"""
        while not self.outbound_queue.empty():
            try:
                self.outbound_queue.get_nowait()
            except asyncio.QueueEmpty:
                break
        logger.info(f"Cleared audio queue for stream: {self.stream_sid}")

    async def _send_loop(self):
        """
        Background task to send queued audio to Twilio.

        Sends at real-time rate (~20ms per chunk) to match playback speed
        and prevent sending faster than Twilio can play.
        """
        while self.running:
            try:
                # Get next audio chunk (blocks if empty)
                payload = await self.outbound_queue.get()

                # Send to Twilio
                message = {
                    "event": "media",
                    "streamSid": self.stream_sid,
                    "media": {
                        "payload": payload
                    }
                }
                await self.websocket.send_text(json.dumps(message))

                # Small delay to match real-time playback rate
                # Prevents sending faster than Twilio can play
                # 20ms per chunk is typical for 8kHz audio
                await asyncio.sleep(0.020)

            except asyncio.CancelledError:
                logger.info("Send loop cancelled")
                break
            except Exception as e:
                logger.error(f"Error sending audio: {e}", exc_info=True)
                break

        logger.info("Send loop exited")
```

Update src/twilio/handlers.py to integrate AudioStreamer:

Add to imports:
```python
from src.audio.buffers import AudioStreamer
```

Add streamer tracking to ConnectionManager:
```python
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.streamers: Dict[str, AudioStreamer] = {}  # Add this

    async def connect(self, call_sid: str, stream_sid: str, websocket: WebSocket):
        # Updated signature to accept stream_sid
        await websocket.accept()
        self.active_connections[call_sid] = websocket

        # Create and start AudioStreamer
        streamer = AudioStreamer(websocket, stream_sid)
        await streamer.start()
        self.streamers[call_sid] = streamer

        logger.info(f"Connection accepted for call: {call_sid}, stream: {stream_sid}")

    async def disconnect(self, call_sid: str):
        # Stop streamer
        streamer = self.streamers.pop(call_sid, None)
        if streamer:
            await streamer.stop()

        self.active_connections.pop(call_sid, None)
        logger.info(f"Connection removed for call: {call_sid}")

    def get_streamer(self, call_sid: str) -> Optional[AudioStreamer]:
        return self.streamers.get(call_sid)
```

Update handle_start to pass stream_sid:
```python
async def handle_start(websocket: WebSocket, data: dict):
    """Handle 'start' event - extract call metadata"""
    start_data = data.get("start", {})
    call_sid = start_data.get("callSid")
    stream_sid = start_data.get("streamSid")
    media_format = start_data.get("mediaFormat", {})

    logger.info(f"Stream started: {stream_sid}, Call: {call_sid}")
    logger.info(f"Media format: {media_format}")

    # Store connection with streamer
    await manager.connect(call_sid, stream_sid, websocket)
```

Update handle_stop to async disconnect:
```python
async def handle_stop(websocket: WebSocket, data: dict):
    """Handle 'stop' event - stream ending"""
    stop_data = data.get("stop", {})
    call_sid = stop_data.get("callSid")

    logger.info(f"Stream stopped: {call_sid}")

    if call_sid:
        await manager.disconnect(call_sid)  # Now async
```

Key requirements from research: Bounded queue (maxsize=50) prevents unbounded memory growth, timeout on queue.put() detects stalls, send at real-time rate (~20ms chunks) to match playback speed, use asyncio.create_task() for background sending.
  </action>
  <verify>
Run `python -c "from src.audio.buffers import AudioStreamer; print('AudioStreamer imports OK')"`.
Run `python -m pytest tests/ -v` (existing tests should still pass).
Verify updated handlers import without errors.
Check logs show "AudioStreamer started" message when test connection established.
  </verify>
  <done>
AudioStreamer class exists with start(), stop(), queue_audio(), clear_queue() methods.
Bounded queue with maxsize=50 prevents memory overflow.
Background send loop runs at real-time rate (20ms delay).
ConnectionManager tracks streamers per call and cleans up on disconnect.
Updated handlers use async disconnect pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement call state management and lifecycle tracking</name>
  <files>
    src/state/__init__.py
    src/state/manager.py
    src/twilio/handlers.py
  </files>
  <action>
Create call state management module in src/state/manager.py following Pattern 5 from research (state machine for call lifecycle):

```python
"""
Call state management for tracking conversation lifecycle.

States:
- IDLE: No active call
- CONNECTING: WebSocket accepted, waiting for 'start' message
- ACTIVE: Call in progress, audio flowing
- STOPPING: Received 'stop' message, cleaning up
- ERROR: Abnormal termination
"""
from enum import Enum
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict
from fastapi import WebSocket
import logging

logger = logging.getLogger(__name__)

class CallState(Enum):
    """Call lifecycle states"""
    IDLE = "idle"
    CONNECTING = "connecting"
    ACTIVE = "active"
    STOPPING = "stopping"
    ERROR = "error"

@dataclass
class CallContext:
    """
    Context for a single call.

    Tracks state, identifiers, and metadata throughout call lifecycle.
    """
    state: CallState
    call_sid: Optional[str] = None
    stream_sid: Optional[str] = None
    websocket: Optional[WebSocket] = None
    connected_at: Optional[datetime] = None
    error_message: Optional[str] = None

    # Audio tracking
    audio_received_count: int = 0
    audio_sent_count: int = 0

class CallStateManager:
    """
    Manages call state transitions and context.

    Prevents race conditions by serializing state changes.
    """

    def __init__(self):
        self.calls: Dict[str, CallContext] = {}
        # Temporary storage for calls before we have call_sid
        self.pending_connections: Dict[int, CallContext] = {}

    async def on_connected(self, websocket: WebSocket) -> tuple[int, CallContext]:
        """
        Handle WebSocket connection.

        Returns:
            Tuple of (temp_id, CallContext) for tracking until call_sid arrives
        """
        ctx = CallContext(
            state=CallState.CONNECTING,
            websocket=websocket
        )

        # Temporarily store by websocket id until we get call_sid
        temp_id = id(websocket)
        self.pending_connections[temp_id] = ctx

        logger.info(f"WebSocket connection pending (temp_id: {temp_id})")
        return temp_id, ctx

    async def on_start(self, temp_id: int, call_sid: str, stream_sid: str) -> CallContext:
        """
        Handle stream start message.

        Moves call from pending to active with proper identifiers.

        Args:
            temp_id: Temporary ID from on_connected
            call_sid: Twilio call identifier
            stream_sid: Twilio stream identifier

        Returns:
            CallContext now tracked by call_sid
        """
        # Get pending context
        ctx = self.pending_connections.pop(temp_id, None)

        if not ctx:
            # Shouldn't happen, but handle gracefully
            logger.warning(f"No pending connection for temp_id: {temp_id}, creating new context")
            ctx = CallContext(state=CallState.CONNECTING)

        # Update context with identifiers
        ctx.call_sid = call_sid
        ctx.stream_sid = stream_sid
        ctx.state = CallState.ACTIVE
        ctx.connected_at = datetime.now()

        # Store by call_sid
        self.calls[call_sid] = ctx

        logger.info(f"Call started: {call_sid}, State: {ctx.state.value}")
        return ctx

    async def on_stop(self, call_sid: str) -> Optional[CallContext]:
        """
        Handle stream stop message.

        Transitions to STOPPING state. Actual cleanup happens in cleanup().

        Args:
            call_sid: Twilio call identifier

        Returns:
            CallContext if found, None otherwise
        """
        ctx = self.calls.get(call_sid)

        if ctx:
            ctx.state = CallState.STOPPING
            logger.info(f"Call stopping: {call_sid}")
        else:
            logger.warning(f"Attempted to stop unknown call: {call_sid}")

        return ctx

    async def on_error(self, call_sid: str, error_message: str) -> Optional[CallContext]:
        """
        Handle error during call.

        Transitions to ERROR state.

        Args:
            call_sid: Twilio call identifier
            error_message: Error description

        Returns:
            CallContext if found, None otherwise
        """
        ctx = self.calls.get(call_sid)

        if ctx:
            ctx.state = CallState.ERROR
            ctx.error_message = error_message
            logger.error(f"Call error: {call_sid}, Error: {error_message}")
        else:
            logger.error(f"Error for unknown call: {call_sid}, Error: {error_message}")

        return ctx

    async def cleanup(self, call_sid: str):
        """
        Remove call from tracking.

        Should be called in finally block of WebSocket handler.

        Args:
            call_sid: Twilio call identifier
        """
        ctx = self.calls.pop(call_sid, None)

        if ctx:
            duration = None
            if ctx.connected_at:
                duration = (datetime.now() - ctx.connected_at).total_seconds()

            logger.info(
                f"Call cleanup: {call_sid}, "
                f"Duration: {duration:.1f}s, "
                f"Audio received: {ctx.audio_received_count}, "
                f"Audio sent: {ctx.audio_sent_count}"
            )
        else:
            logger.warning(f"Cleanup for unknown call: {call_sid}")

    def get_context(self, call_sid: str) -> Optional[CallContext]:
        """Get call context by call_sid"""
        return self.calls.get(call_sid)

    def get_active_calls(self) -> Dict[str, CallContext]:
        """Get all active calls"""
        return {
            call_sid: ctx
            for call_sid, ctx in self.calls.items()
            if ctx.state == CallState.ACTIVE
        }

    def get_call_count(self) -> int:
        """Get total number of tracked calls"""
        return len(self.calls)
```

Create __init__.py:
```python
"""Call state management"""
from .manager import CallStateManager, CallState, CallContext

__all__ = ["CallStateManager", "CallState", "CallContext"]
```

Integrate state manager into src/twilio/handlers.py:

Add import:
```python
from src.state.manager import CallStateManager

# Create global state manager instance
state_manager = CallStateManager()
```

Update handlers to use state manager:

In handle_connected:
```python
async def handle_connected(websocket: WebSocket, data: dict):
    """Handle 'connected' event from Twilio"""
    logger.info("WebSocket connected to Twilio")
    temp_id, ctx = await state_manager.on_connected(websocket)
    # Store temp_id for later retrieval in handle_start
    websocket.state.temp_id = temp_id  # Store on websocket for access
```

In handle_start:
```python
async def handle_start(websocket: WebSocket, data: dict):
    """Handle 'start' event - extract call metadata"""
    start_data = data.get("start", {})
    call_sid = start_data.get("callSid")
    stream_sid = start_data.get("streamSid")

    # Get temp_id from websocket state
    temp_id = getattr(websocket.state, 'temp_id', id(websocket))

    # Update state manager
    ctx = await state_manager.on_start(temp_id, call_sid, stream_sid)

    logger.info(f"Stream started: {stream_sid}, Call: {call_sid}, State: {ctx.state.value}")

    # Store connection with streamer
    await manager.connect(call_sid, stream_sid, websocket)
```

In handle_media:
```python
async def handle_media(websocket: WebSocket, data: dict):
    """Handle 'media' event - receive audio from Twilio"""
    # ... existing code ...

    # Track audio received
    call_sid = data.get("callSid")  # May need to extract from context
    if call_sid:
        ctx = state_manager.get_context(call_sid)
        if ctx:
            ctx.audio_received_count += 1
```

In handle_stop:
```python
async def handle_stop(websocket: WebSocket, data: dict):
    """Handle 'stop' event - stream ending"""
    stop_data = data.get("stop", {})
    call_sid = stop_data.get("callSid")

    # Update state
    await state_manager.on_stop(call_sid)

    logger.info(f"Stream stopped: {call_sid}")

    if call_sid:
        await manager.disconnect(call_sid)
        await state_manager.cleanup(call_sid)
```

Update main.py WebSocket handler to use state cleanup:
```python
finally:
    # Cleanup on disconnect
    if call_sid:
        await manager.disconnect(call_sid)
        await state_manager.cleanup(call_sid)
```
  </action>
  <verify>
Run `python -c "from src.state.manager import CallStateManager, CallState; print('State manager imports OK')"`.
Run server and check logs show state transitions (CONNECTING → ACTIVE).
Verify health endpoint shows active call count correctly.
  </verify>
  <done>
CallStateManager class exists with state transition methods.
CallState enum defines lifecycle states (IDLE, CONNECTING, ACTIVE, STOPPING, ERROR).
CallContext dataclass tracks call metadata and audio counts.
Handlers integrate state manager for all lifecycle events.
State transitions logged for debugging.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement outbound call initiation via Twilio SDK</name>
  <files>
    src/twilio/__init__.py
    src/twilio/client.py
    src/main.py
  </files>
  <action>
Create Twilio client module in src/twilio/client.py for outbound calls:

```python
"""
Twilio API client for outbound call initiation.

Provides functions to create calls programmatically using Twilio SDK.
"""
from twilio.rest import Client
from twilio.twiml.voice_response import VoiceResponse, Connect, Stream
from src.config import settings
import logging

logger = logging.getLogger(__name__)

def get_twilio_client() -> Client:
    """
    Get authenticated Twilio client.

    Returns:
        Configured Twilio client instance

    Raises:
        ValueError: If credentials not configured
    """
    if not settings.twilio_account_sid or not settings.twilio_auth_token:
        raise ValueError("Twilio credentials not configured in environment")

    return Client(settings.twilio_account_sid, settings.twilio_auth_token)

def generate_twiml(websocket_url: str) -> str:
    """
    Generate TwiML for Media Streams connection.

    Args:
        websocket_url: Full WSS URL for Twilio to connect to (e.g., wss://your-domain.com/ws)

    Returns:
        TwiML XML string
    """
    response = VoiceResponse()
    connect = Connect()
    stream = Stream(url=websocket_url)
    connect.append(stream)
    response.append(connect)

    twiml_str = str(response)
    logger.debug(f"Generated TwiML: {twiml_str}")
    return twiml_str

async def create_outbound_call(
    to_number: str,
    websocket_url: str,
    from_number: str = None
) -> dict:
    """
    Initiate an outbound call via Twilio.

    Args:
        to_number: Phone number to call (E.164 format, e.g., +15551234567)
        websocket_url: Full WSS URL for Media Streams connection
        from_number: Optional caller ID (defaults to configured Twilio number)

    Returns:
        Dict with call details (call_sid, status, etc.)

    Raises:
        Exception: If call creation fails
    """
    if not from_number:
        from_number = settings.twilio_phone_number

    if not from_number:
        raise ValueError("from_number must be specified or TWILIO_PHONE_NUMBER configured")

    try:
        client = get_twilio_client()

        # Generate TwiML for this call
        twiml = generate_twiml(websocket_url)

        # Create call
        call = client.calls.create(
            to=to_number,
            from_=from_number,
            twiml=twiml
        )

        logger.info(
            f"Outbound call created: {call.sid}, "
            f"To: {to_number}, From: {from_number}, Status: {call.status}"
        )

        return {
            "call_sid": call.sid,
            "status": call.status,
            "to": to_number,
            "from": from_number,
            "direction": "outbound-api"
        }

    except Exception as e:
        logger.error(f"Failed to create outbound call to {to_number}: {e}", exc_info=True)
        raise
```

Update src/twilio/__init__.py:
```python
"""Twilio integration modules"""
from .client import create_outbound_call, generate_twiml, get_twilio_client
from .handlers import manager, MESSAGE_HANDLERS
from .models import TwilioMessage, StartMessage, MediaPayload

__all__ = [
    "create_outbound_call",
    "generate_twiml",
    "get_twilio_client",
    "manager",
    "MESSAGE_HANDLERS",
    "TwilioMessage",
    "StartMessage",
    "MediaPayload",
]
```

Add TwiML endpoint to src/main.py:

```python
from fastapi.responses import Response
from src.twilio.client import generate_twiml

@app.get("/twiml")
async def twiml_endpoint():
    """
    Serve TwiML to establish Media Stream.

    This endpoint can be configured as the Voice URL for a Twilio phone number
    to handle inbound calls.

    For local development, use ngrok URL (e.g., https://abc123.ngrok.io/twiml)
    """
    # Construct WebSocket URL from current request
    # In production, use actual domain; for dev, use ngrok
    # For now, use placeholder - will be replaced in testing plan
    websocket_url = f"wss://{settings.server_host}/ws"

    # Note: This is a placeholder. In practice, you'd configure this via
    # environment variable or derive from request headers.
    # Example: websocket_url = f"wss://{request.headers.get('host')}/ws"

    twiml = generate_twiml(websocket_url)
    return Response(content=twiml, media_type="application/xml")

@app.post("/call/outbound")
async def initiate_outbound_call(to_number: str, websocket_url: str):
    """
    API endpoint to initiate an outbound call.

    Args:
        to_number: Phone number to call (E.164 format)
        websocket_url: WebSocket URL for Media Streams (typically ngrok URL for dev)

    Returns:
        Call details including call_sid

    Example:
        POST /call/outbound?to_number=+15551234567&websocket_url=wss://abc123.ngrok.io/ws
    """
    from src.twilio.client import create_outbound_call

    try:
        result = await create_outbound_call(to_number, websocket_url)
        return result
    except Exception as e:
        return {"error": str(e)}, 500
```

Key requirements: Use Twilio SDK client.calls.create() API, generate TwiML with Stream tag for WebSocket connection, provide both TwiML endpoint (for inbound) and outbound API, follow research Pattern 6 for configuration.
  </action>
  <verify>
Run `python -c "from src.twilio.client import generate_twiml; print(generate_twiml('wss://test.com/ws'))"` and verify valid TwiML XML output.
Run `python -m src.main` and verify /twiml endpoint exists.
Check `/twiml` endpoint returns XML: `curl http://localhost:8000/twiml`.
Verify imports work without errors.
  </verify>
  <done>
Twilio client module exports create_outbound_call and generate_twiml functions.
TwiML generation produces valid XML with Stream tag.
FastAPI app has /twiml GET endpoint returning TwiML.
FastAPI app has /call/outbound POST endpoint for programmatic calls.
Outbound call function uses Twilio SDK and logs call details.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. AudioStreamer starts and stops without errors
2. Backpressure handling prevents queue overflow (verify queue depth logging)
3. Call state transitions correctly: CONNECTING → ACTIVE → STOPPING
4. State cleanup logs show duration and audio counts
5. TwiML endpoint returns valid XML
6. Outbound call API endpoint exists (can test with mock credentials)

Overall phase validation:
- [ ] Bidirectional streaming works without blocking
- [ ] Call state tracked throughout lifecycle
- [ ] Audio queue prevents overflow
- [ ] Outbound calls can be initiated
- [ ] TwiML endpoint serves valid configuration
</verification>

<success_criteria>
**Measurable completion:**

1. AudioStreamer successfully queues and sends audio with backpressure
2. Queue depth logs show bounded behavior (max 50 items)
3. CallStateManager transitions states correctly (visible in logs)
4. CallContext tracks audio_received_count and audio_sent_count
5. `/twiml` endpoint returns valid TwiML XML with Stream tag
6. `/call/outbound` endpoint exists and accepts parameters
7. Twilio SDK client.calls.create() integration works (verifiable with valid credentials)
8. State cleanup logs show call duration and counts

**Ready for next plan when:**
- Bidirectional streaming infrastructure is operational
- Call lifecycle is tracked from connection to cleanup
- Outbound call capability is implemented
- All integrations work together without blocking issues
</success_criteria>

<output>
After completion, create `.planning/phases/01-telephony-foundation-audio-pipeline/01-02-SUMMARY.md`
</output>
